# Special object methods

In python, All the built-in types inherit from object:
(Interesting, bool inherits from int)
`owner.__class__.__bases__` is the way to find one object's base class, besides, the bases has to return back a tuple, beacuse it can have multiple base classes.

*a one-element tuple: `(1,)`

It need a comma to claim it is a tuple. `(1)` is just `1`


## Built-in object attributes
ask `dir()`, a built-in function that returns a list of all the attributes on an object.

* For string representation: `__repr__, __str__, __format__`
* For comparisons: `__eq__, __ge__, __gt__, __le__, __lt__, __ne__`
* Related to classes:` __bases__, __class__, __new__, __init__, __init_subclass__, __subclasshook__, __setattr__, __delattr__, __getattribute__`
* Others: `__dir__, __hash__, __module__, __reduce__, __reduce_ex__`

### `__str__`
The `__str__` method returns a human readable string representation of an object.

The `__str__` method is used in multiple places by Python: `print() function, str() constructor, f-strings, and more.`

**Override `__str__`**

When making custom classes, we can override `__str__` to define our human readable string representation.

```py
class Lamb:
    species_name = "Lamb"
    scientific_name = "Ovis aries"

    def __init__(self, name):
        self.name = name

    def __str__(self):
        return "üêë : " + self.name
```

### `__repr__`

The `__repr__` method returns a string that would evaluate to an object with the same values.

If implemented correctly, calling eval() on the result should return back that same-valued object.

```py
from fractions import Fraction

one_half = Fraction(1, 2)
Fraction.__repr__(one_half)           # 'Fraction(1, 2)'
# == one_half.__repr__()
# == repr(one_half)
another_half = eval(Fraction.__repr__(one_half))
```

when repr(object) is called and when displaying an object in an **interactive Python session.**

The override to `__repr__()` can make debug easier

### Attribute access

We can use dot to access the attribute in one object, but when an attribute doesn't exist in this class, it will cause error.

**Get attribute with getattr()**:getattr(object, name[, default]) looks up the attribute by name on object.

If it's undefined, it returns default if provided or raises AttributeError otherwise.

`getattr(bunny, "tie_ears", lambda self: print("ears tied!"))`

**When we call object.name or getattr(object, name), Python calls `__getattribute__` on the object.**

No matter attribute or method, when we call them, we will call the `__g...e__`

So you don't use dot notation unless you are very certain that an attribute is on that object.(try except is not simple)

### Check attribute exists with hasattr()
`hasattr(object, name)` looks up the attribute by name on object and returns whether it can find such an attribute.(name should be str)

Python implements this function by calling getattr() and checking to see if an exception is returned, so this function also ends up calling __getattribute__.

